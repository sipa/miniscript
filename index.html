<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Miniscript</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
        <!-- Optional theme -->
        <link rel="stylesheet" href="style.css">
        <style>
            .monospace {
                font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace;
            }
            a.demo_link {
                text-decoration-style: dashed;
                text-underline-position: under;
            }
        </style>
    </head>
<body>
<script src="miniscript.js"></script>
<script>
em_miniscript_compile = Module.cwrap('miniscript_compile', 'none', ['string', 'number', 'number', 'number', 'number']);
em_miniscript_analyze = Module.cwrap('miniscript_analyze', 'none', ['string', 'number', 'number']);

function miniscript_compile() {
    document.getElementById("descout").value = "Compiling...";
    document.getElementById("spendout").innerHTML = "Compiling...";
    window.setTimeout(function() {
        src = document.getElementById("source").value;
        var descout = Module._malloc(1000);
        var spendout = Module._malloc(50000);
        em_miniscript_compile(src, descout, 1000, spendout, 50000);
        document.getElementById("descout").value = Module.UTF8ToString(descout);
        document.getElementById("spendout").innerHTML = Module.UTF8ToString(spendout);
        Module._free(descout)
        Module._free(spendout)
    });
}

function miniscript_analyze() {
    document.getElementById("spendout").innerHTML = "Analyzing...";
    window.setTimeout(function() {
        src = document.getElementById("descout").value;
        var spendout = Module._malloc(50000);
        em_miniscript_analyze(src, spendout, 50000);
        document.getElementById("spendout").innerHTML = Module.UTF8ToString(spendout);
        Module._free(spendout)
    });
}

</script>

<div class="container" style="margin-top:50px">

<div class="card mb-3 text-left">
<h3 class="card-header">Miniscript introduction</h3>
<div class="card-block">
<p>
Some explanation goes here.
</p>
</div>
</div>

<div class="card mb-3 text-left">
<h3 class="card-header">Compiler demo</h3>
<div class="card-block">

<textarea rows="1" cols="100" id="source">
and(pk(C),or(pk(C),or(9@pk(C),older(1000))))
</textarea><br/>
<button type="button" onclick="miniscript_compile();">Compile</button>
Supported elements:
<ul>
<li><b>pk(HEX)</b>: Require public key HEX to sign.</li>
<li><b>time(NUMBER)</b>: Require that a relative time NUMBER has passed since creating the output.</li>
<li><b>hash(HEX)</b>: Require that the SHA256 preimage of HEX is revealed.</li>
<li><b>and(EXPR,EXPR)</b>: Require that both subexpressions are satisfied.</li>
<li><b>or([N@]EXPR,[N@]EXPR)</b>: Require that one of the subexpressions is satisfied. The numbers N indicate the relative probability of each of the subexpressions.</li>
<li><b>thresh(NUM,EXPR,EXPR,...)</b>: Require that NUM out of the following subexpressions are satisfied.</li>
</ul>
Shorthands:
<ul>
<li><b>C</b>: A dummy compressed public key (usable as argument to pk or multi)</li>
<li><b>U</b>: A dummy uncompressed public key (usable as argument to pk or multi)</li>
<li><b>H</b>: A dummy hash (usable as argument to hash)</li>
</ul>

<hr/>
<b>Miniscript output</b><br/>
<textarea rows="4" cols="100" id="descout"></textarea>
<button type="button" onclick="miniscript_analyze();">Analyze</button>

<hr/>
<b>Analysis</b><br/>
<a id="spendout"></a>
</div>
</div>


<div class="card text-left">
<h3 class="card-header">Miniscript reference</h3>
<div class="card-block">

<table border="1">
<tr><th>Type</th><th>Shorthand</th><th>Behavior under honest inputs</th><th>Behavior under adverserial inputs</th></tr>
<tr><td>Base</td><td>B</td><td>Takes its inputs from the top of the stack. Pushes a nonzero value of up to 4 bytes if the condition is satisfied, exactly zero otherwise.</td><td>Pushes zero onto the stack, or aborts.</td></tr>
<tr><td>Key</td><td>K</td><td>Takes its inputs from the top of the stack. Pushes a public key with which a checksig is to be done onto the stack.</td><td>Aborts.</td></tr>
<tr><td>Verify</td><td>V</td><td>Takes its inputs from the top of the stack, which must satisfy the condition. Does not push anything onto the stack.</td><td>Aborts.</td></tr>
<tr><td>Wrapped</td><td>W</td><td>Takes from the stack its inputs + element X at the top. If the inputs satisfy the condition, [t X] or [X t] is pushed, where t is a nonzero value of up to 4 bytes. If not, [0 X] or [X 0] is pushed.</td><td>Pushes [0 X] or [X 0] onto the stack, or aborts.</td></tr>
</table>

In addition, every expression can have zero or more of the following properties used for reasoning about correctness:<ul>
<li><b>z</b> "zero": Known to consume exactly zero stack elements. Conflicts with "o".</li>
<li><b>o</b> "one": Known to consume exactly one stack element. Conflicts with "z".</li>
<li><b>n</b> "nonzero": Known to consume at least one stack element, and the top element is never required to be 0 to satisfy the condition. Conflicts with "z". Impossible for W.</li>
<li><b>d</b> "dissatisfiable": There is a guaranteed way to this dissatisfy the expression. Impossible for V.</li>
<li><b>u</b> "unit": Satisfaction always results in an exact 1 on the stack (as opposed to arbitrary nonzero value). Impossible for V. Implied by K</li>
</ul>

There are also four more properties that let us reason about nonmalleability:<ul>
<li><b>e</b> "expr": A unique way to dissatisfy this expression exists which cannot be modified into another dissatisfaction by an attacker. Conflicts with "f". Implies "d". Impossible for V.</li>
<li><b>f</b> "forced": There is no way to dissatisfy the expression, either under honest or malicious input. Conflicts with "d" and "e". Implied by V.</li>
<li><b>s</b> "safe": Satisfying this expression requires at least one signature. This means a dissatisfaction cannot be converted into a satisfaction for this expression. Implied by K.</li>
<li><b>m</b> "nonmalleable": For every way the condition can be met, a unique satisfaction exists which cannot be modified into another satisfaction by an attacker. Implied by Z.</li>
</ul>

<h3>Legend</h3>

<table border="1">
<tr>
  <th>Semantics</th>
  <th>Node</th>
  <th>Script</th>
  <th>nsat</th>
  <th>sat (X,Y)</th>
  <th>sat Z</th>
  <th>Types</th>
  <th>Req.</th>
  <th>Corr. prop.</th>
  <th>Mall. prop.</th>
</tr>
<tr>
  <td rowspan="2">check(key)</td>
  <td>pk(key)</td>
  <td>key</td>
  <td>0</td>
  <td>sig</td>
  <td>-</td>
  <td>K</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td>pk_h(keyhash)</td>
  <td>DUP HASH160 keyhash EQUALVERFIFY</td>
  <td>0 key</td>
  <td>sig key</td>
  <td>-</td>
  <td>K</td>
  <td></td>
  <td>n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td>nSequence &ge; n (and compatible)</td>
  <td>older(n)</td>
  <td>n CHECKSEQUENCEVERIFY</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td>n &ge; 1</td>
  <td>z</td>
  <td>f, m</td>
</tr>
<tr>
  <td>nLockTime &ge; n (and compaitlbe)</td>
  <td>after(n)</td>
  <td>n CHECKLOCKTIMEVERIFY</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td>2<sup>31</sup> > n &ge; 1</td>
  <td>z</td>
  <td>f, m</td>
</tr>
<tr>
  <td>len(x) = 32 and SHA256(x) = h</td>
  <td>sha256(h)</td>
  <td>SIZE 32 EQUALVERIFY SHA256 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and HASH256(x) = h</td>
  <td>hash256(h)</td>
  <td>SIZE 32 EQUALVERIFY HASH256 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and RIPEMD160(x) = h</td>
  <td>ripemd160(h)</td>
  <td>SIZE 32 EQUALVERIFY RIPEMD160 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and HASH160(x) = h</td>
  <td>hash160(h)</td>
  <td>SIZE 32 EQUALVERIFY HASH160 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td rowspan="3">X and Y</td>
  <td>and_v(X,Y)</td>
  <td>[X] [Y]</td>
  <td>-</td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=V<sub>X</sub>B<sub>Y</sub><br />K=V<sub>X</sub>K<sub>Y</sub><br />V=V<sub>X</sub>V<sub>Y</sub></td>
  <td></td>
  <td>
      u=u<sub>Y</sub><br />
      n=n<sub>X</sub>+z<sub>X</sub>n<sub>Y</sub><br />
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>+o<sub>X</sub>z<sub>Y</sub>
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Y</sub>[=f<sub>Y</sub>]<br />
      m=m<sub>X</sub>m<sub>Y</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td>and_b(X,Y)</td>
  <td>[X] [Y] BOOLAND</td>
  <td>nsat<sub>Y</sub> nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub>W<sub>Y</sub></td>
  <td></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>+o<sub>X</sub>z<sub>Y</sub><br />
      n=n<sub>X</sub>+z<sub>X</sub>n<sub>Y</sub><br />
      d=d<sub>X</sub>d<sub>Y</sub><br />
      u
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Y</sub><br />
      e=e<sub>X</sub>e<sub>Y</sub>s<sub>X</sub>s<sub>Y</sub><br />
      m=m<sub>X</sub>m<sub>Y</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td>and_n(X,Y)</td>
  <td>[X] NOTIF 0 ELSE [Y] ENDIF (=andor(X,Y,0))</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub>B<sub>Y</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=o<sub>X</sub>z<sub>Y</sub><br />
      u=u<sub>Y</sub><br />
      d=d<sub>X</sub>[=1]
  </td>
  <td>
      f=f<sub>Y</sub>f<sub>X</sub>[=0]<br />
      e=e<sub>X</sub>(s<sub>X</sub>+f<sub>Y</sub>)<br />
      m=m<sub>X</sub>m<sub>Y</sub>e<sub>X</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td rowspan="4">X or Z</td>
  <td>or_b(X,Z)</td>
  <td>[X] [Z] BOOLOR</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>nsat<sub>Z</sub> sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>W<sub>Z</sub></td>
  <td>d<sub>X</sub>d<sub>Z</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=z<sub>X</sub>o<sub>Z</sub>+o<sub>X</sub>z<sub>Z</sub><br />
      d=d<sub>X</sub>d<sub>Z</sub>[=1]<br />
      u
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=0]<br />
      e=e<sub>X</sub>e<sub>Z</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>e<sub>Z</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_d(X,Z)</td>
  <td>[X] IFDUP NOTIF [Z] ENDIF</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>B<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=o<sub>X</sub>z<sub>Z</sub><br />
      u=u<sub>X</sub>(f<sub>X</sub>+u<sub>Z</sub>)[=u<sub>Z</sub>]<br />
      d=d<sub>X</sub>d<sub>Z</sub>[=d<sub>Z</sub>]
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=f<sub>Z</sub>]<br />
      e=e<sub>X</sub>e<sub>Z</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_c(X,Z)</td>
  <td>[X] NOTIF [Z] ENDIF</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>V=B<sub>X</sub>V<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=o<sub>X</sub>z<sub>Z</sub>
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=1]<br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_i(X,Z)</td>
  <td>IF [X] ELSE [Z] ENDIF</td>
  <td>nsat<sub>X</sub> 1<br />nsat<sub>Z</sub> 0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>sat<sub>Z</sub> 0</td>
  <td>V=V<sub>X</sub>V<sub>Z</sub><br />B=B<sub>X</sub>B<sub>Z</sub><br />K=K<sub>X</sub>K<sub>Z</sub></td>
  <td></td>
  <td>
      o=z<sub>X</sub>z<sub>Z</sub><br />
      u=u<sub>X</sub>u<sub>Z</sub><br />
      d=d<sub>X</sub>+d<sub>Z</sub>
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Z</sub><br />
      e=e<sub>X</sub>f<sub>Z</sub>+e<sub>Z</sub>f<sub>X</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>(X and Y) or Z</td>
  <td>andor(X,Y,Z)</td>
  <td>[X] NOTIF [Z] ELSE [Y] ENDIF</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>B<sub>Y</sub>B<sub>Z</sub><br />K=B<sub>X</sub>K<sub>Y</sub>K<sub>Z</sub><br />V=B<sub>X</sub>V<sub>Y</sub>V<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub>+o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub><br />
      u=u<sub>Y</sub>u<sub>Z</sub><br />
      d=d<sub>X</sub>d<sub>Z</sub>[=d<sub>Z</sub>]
  </td>
  <td>
      f=f<sub>Y</sub>(f<sub>X</sub>+f<sub>Z</sub>)[=f<sub>Y</sub>f<sub>Z</sub>]<br />
      e=e<sub>X</sub>e<sub>Z</sub>(s<sub>X</sub>+f<sub>Y</sub>)<br />
      m=m<sub>X</sub>m<sub>Y</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Y</sub>+s<sub>Z</sub>)<br />
      s=s<sub>Z</sub>(s<sub>X</sub>+s<sub>Y</sub>)
  </td>
</tr>
<tr>
  <td>X<sub>1</sub> + ... + X<sub>n</sub> = k</td>
  <td>thresh(k,...)</td>
  <td>[X<sub>1</sub>] ([X<sub>i</sub> ADD)*(n-1) k EQUAL</td>
  <td>nsat...</td>
  <td>(sat|nsat)...</td>
  <td>-</td>
  <td>B=X<sub>1</sub> is B<br />others are W</td>
  <td>n > k > 1<br />all are d and u</td>
  <td>
      z=all are z<br />
      o=all are z, except one is o<br />
      d<br />
      u
  </td>
  <td>
      e=all are e and s<br />
      m=all are e and m, &ge;(n-k) are s<br />
      s=&ge;(n-k+1) are s
  </td>
</tr>
<tr>
  <td>check(key_1) + ... = k</td>
  <td>thresh_m(k,...)</td>
  <td>k key_1 ... key_n n CHECKMULTISIG</td>
  <td>0 0 ... 0</td>
  <td>0 sig...</td>
  <td>-</td>
  <td>B</td>
  <td>n &ge; k &ge; 1</td>
  <td>n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td rowspan="10">X</td>
  <td>a:X</td>
  <td>TOALTSTACK [X] FROMALTSTACK</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>W=B<sub>X</sub></td>
  <td></td>
  <td>u=u<sub>X</sub>, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>s:X</td>
  <td>SWAP [X]</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>o<sub>X</sub></td>
  <td>W=B<sub>X</sub></td>
  <td></td>
  <td>u=u<sub>x</sub>, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>c:X</td>
  <td>[X] CHECKSIG</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=K<sub>X</sub></td>
  <td></td>
  <td>o=o<sub>X</sub>, n=n<sub>X</sub>, u, d=d<sub>X</sub></td>
  <td>e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub>[=1]</td>
</tr>
<tr>
  <td>t:X</td>
  <td>[X] 1 (=and_v(X,1))</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=V<sub>X</sub></td>
  <td></td>
  <td>u, n=n<sub>X</sub>, z=z<sub>X</sub>, o=o<sub>X</sub></td>
  <td>f, m=m<sub>X</sub>, s=s<sub>X</sub></td>
<tr>
  <td>d:X</td>
  <td>DUP IF [X] ENDIF</td>
  <td>0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>-</td>
  <td>B=V<sub>X</sub></td>
  <td>z<sub>X</sub></td>
  <td>o=z<sub>X</sub>, n, u, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>v:X</td>
  <td>[X] VERIFY</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>V=B<sub>X</sub></td>
  <td></td>
  <td>z=z<sub>X</sub>, o=o<sub>X</sub>, n=n<sub>X</sub></td>
  <td>f, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>j:X</td>
  <td>SIZE 0NOTEQUAL IF [X] ENDIF</td>
  <td>0</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td>n<sub>X</sub></td>
  <td>o=o<sub>X</sub>, n, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>n:X</td>
  <td>[X] 0NOTEQUAL</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>z=z<sub>X</sub>, o=o<sub>X</sub>, n=n<sub>X</sub>, u, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>l:X</td>
  <td>IF 0 ELSE [X] ENDIF (=or_i(0,X))</td>
  <td>1</td>
  <td>sat<sub>X</sub> 0</td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>o=z<sub>X</sub>, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>u:X</td>
  <td>IF [X] ELSE 0 ENDIF (=or_i(X,0))</td>
  <td>0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>o=z<sub>X</sub>, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>true</td>
  <td>1</td>
  <td>1</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>z, u</td>
  <td>f, m</td>
</tr>
<tr>
  <td>false</td>
  <td>0</td>
  <td>0</td>
  <td>[]</td>
  <td>-</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>z, u, d</td>
  <td>e, m, s</td>
</tr>
</table>

</div>
</div>
</div>

</body>
</html>
