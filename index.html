<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Miniscript</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
        <!-- Optional theme -->
        <link rel="stylesheet" href="style.css">
        <style>
            .monospace {
                font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace;
            }
            a.demo_link {
                text-decoration-style: dashed;
                text-underline-position: under;
            }
        </style>
    </head>
<body>
<script src="miniscript.js"></script>
<script>
em_miniscript_compile = Module.cwrap('miniscript_compile', 'none', ['string', 'number', 'number', 'number', 'number']);
em_miniscript_analyze = Module.cwrap('miniscript_analyze', 'none', ['string', 'number', 'number']);

function miniscript_compile() {
    document.getElementById("descout").value = "Compiling...";
    document.getElementById("spendout").innerHTML = "Compiling...";
    window.setTimeout(function() {
        src = document.getElementById("source").value;
        var descout = Module._malloc(1000);
        var spendout = Module._malloc(50000);
        em_miniscript_compile(src, descout, 1000, spendout, 50000);
        document.getElementById("descout").value = Module.UTF8ToString(descout);
        document.getElementById("spendout").innerHTML = Module.UTF8ToString(spendout);
        Module._free(descout)
        Module._free(spendout)
    });
}

function miniscript_analyze() {
    document.getElementById("spendout").innerHTML = "Analyzing...";
    window.setTimeout(function() {
        src = document.getElementById("descout").value;
        var spendout = Module._malloc(50000);
        em_miniscript_analyze(src, spendout, 50000);
        document.getElementById("spendout").innerHTML = Module.UTF8ToString(spendout);
        Module._free(spendout)
    });
}

</script>

<div class="container" style="margin-top:50px">

<div class="card mb-3 text-left">
<h3 class="card-header">Introduction</h3>
<div class="card-block">
<p>
<em>Miniscript</em> is a language for writing (a subset of) Bitcoin Scripts in a structured way, enabling analysis, composition, generic signing and more.
</p>

<p>
Bitcoin Script is an unusual stack-based language with many edge cases, designed for implementing spending conditions consisting of various combinations of
signatures, hash locks, and time locks). Yet despite being limited in functionality it is still highly nontrivial to:<ul>
<li>Given a combination of spending conditions, finding the most economical script to implement it.</li>
<li>Given a two scripts, construct a script that implements a composition of their spending conditions (e.g. a multisig where one of the "keys" in another multisig).</li>
<li>Given a script, find out what spending conditions it permits.</li>
<li>Given a script and access to a sufficient set of private keys, construct a general satisfying witness for it.</li>
<li>Given a script, be able to predict the cost of spending an output.</li>
</ul>
</p>

<p>
Miniscript functions as a representation for scripts that makes these sort of operations possible. It has a structure that allows composition. It is very easy to 
statically analyze for various properties (spending conditions, correctness, security properties, malleability, ...). It can be targeted by spending policy compilers
(see further). Finally, compatible scripts easily can be converted to miniscript - avoiding the need for additional metadata for e.g. signing devices that support it.
</p>
</div>
</div>

<div class="card mb-3 text-left">
<h3 class="card-header">Miniscript reference</h3>
<div class="card-block">
<h4>Mapping between Miniscript and Bitcoin Script</h4>
<table class="table table-sm">
<thead class="thead-light">
<tr><th scope="col">Semantics</th><th scope="col">Miniscript</th><th scope="col">Bitcoin Script</th></tr></thead>
<tbody>
<tr>
  <td>true</td>
  <td><code>1</code></td>
  <td><samp>OP_1</samp></td>
</tr>
<tr>
  <td>false</td>
  <td><code>0</code></td>
  <td><samp>OP_0</samp></td>
</tr>
<tr>
  <td rowspan="2">check(key)</td>
  <td><code>pk(key)</code></td>
  <td><samp>&lt;key&gt;</samp></td>
</tr>
<tr>
  <td><code>pk_h(key)</code></td>
  <td><samp>OP_DUP OP_HASH160 &lt;HASH160(key)&gt; OP_EQUALVERFIFY</samp></td>
</tr>
<tr>
  <td>nSequence &ge; n (and compatible)</td>
  <td><code>older(n)</code></td>
  <td><samp>&lt;n&gt; OP_CHECKSEQUENCEVERIFY</samp></td>
</tr>
<tr>
  <td>nLockTime &ge; n (and compaitlbe)</td>
  <td><code>after(n)</code></td>
  <td><samp>&lt;n&gt; OP_CHECKLOCKTIMEVERIFY</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and SHA256(x) = h</td>
  <td><code>sha256(h)</code></td>
  <td><samp>OP_SIZE &lt;32&gt; OP_EQUALVERIFY OP_SHA256 &lt;h&gt; OP_EQUAL</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and HASH256(x) = h</td>
  <td><code>hash256(h)</code></td>
  <td><samp>OP_SIZE &lt;32&gt; OP_EQUALVERIFY OP_HASH256 &lt;h&gt; OP_EQUAL</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and RIPEMD160(x) = h</td>
  <td><code>ripemd160(h)</code></td>
  <td><samp>OP_SIZE &lt;32&gt; OP_EQUALVERIFY OP_RIPEMD160 &lt;h&gt; OP_EQUAL</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and HASH160(x) = h</td>
  <td><code>hash160(h)</code></td>
  <td><samp>OP_SIZE &lt;32&gt; OP_EQUALVERIFY OP_HASH160 &lt;h&gt; OP_EQUAL</samp></td>
<tr>
  <td>(<em>X</em> and Y) or <em>Z</em></td>
  <td><code>andor(<em>X</em>,Y,<em>Z</em>)</code></td>
  <td><samp><em>X</em> OP_NOTIF <em>Z</em> OP_ELSE <em>Y</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td rowspan="3"><em>X</em> and Y</td>
  <td><code>and_v(<em>X</em>,Y)</code></td>
  <td><samp><em>X</em> <em>Y</em></samp></td>
</tr>
<tr>
  <td><code>and_b(<em>X</em>,Y)</code></td>
  <td><samp><em>X</em> <em>Y</em> OP_BOOLAND</samp></td>
</tr>
<tr>
  <td><code>and_n(<em>X</em>,Y) = andor(<em>X</em>,<em>Y</em>,0)</code></td>
  <td><samp><em>X</em> OP_NOTIF OP_0 OP_ELSE <em>Y</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td rowspan="4"><em>X</em> or <em>Z</em></td>
  <td><code>or_b(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp><em>X</em> <em>Z</em> OP_BOOLOR</samp></td>
</tr>
<tr>
  <td><code>or_d(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp><em>X</em> OP_IFDUP OP_NOTIF <em>Z</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td><code>or_c(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp><em>X</em> OP_NOTIF <em>Z</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td><code>or_i(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp>OP_IF <em>X</em> OP_ELSE <em>Z</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td><em>X</em> + <em>Y</em> + <em>Z</em> + ... = k</td>
  <td><code>thresh(k,<em>X</em>,<em>Y</em>,<em>Z</em>,...)</code></td>
  <td><samp><em>X</em> <em>Y</em> OP_ADD <em>Z</em> OP_ADD ... &lt;k&gt; OP_EQUAL</samp></td>
</tr>
<tr>
  <td>check(key<sub>1</sub>) + ... + check(key<sub>n</sub>) = k</td>
  <td><code>thresh_m(k,key<sub>1</sub>,...,key<sub>n</sub>)</code></td>
  <td><samp>&lt;k&gt; &lt;key<sub>1</sub>&gt; ... &lt;key<sub>n</sub>&gt; &lt;n&gt; OP_CHECKMULTISIG</samp></td>
</tr>
<tr>
  <td rowspan="10"><em>X</em> (identities)</td>
  <td><code>a:<em>X</em></code></td>
  <td><samp>OP_TOALTSTACK <em>X</em> OP_FROMALTSTACK</samp></td>
</tr>
<tr>
  <td><code>s:<em>X</em></code></td>
  <td><samp>OP_SWAP <em>X</em></samp></td>
</tr>
<tr>
  <td><code>c:<em>X</em></code></td>
  <td><samp><em>X</em> OP_CHECKSIG</samp></td>
</tr>
<tr>
  <td><code>t:<em>X</em></code> = <code>and_v(<em>X</em>,1)</code></td>
  <td><samp><em>X</em> OP_1</samp></td>
<tr>
  <td><code>d:<em>X</em></code></td>
  <td><samp>OP_DUP OP_IF <em>X</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td><code>v:<em>X</em></code></td>
  <td><samp><em>X</em> OP_VERIFY (or VERIFY version of last opcode in <em>X</em>)</samp></td>
</tr>
<tr>
  <td><code>j:<em>X</em></code></td>
  <td><samp>OP_SIZE OP_0NOTEQUAL OP_IF <em>X</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td><code>n:<em>X</em></code></td>
  <td><samp><em>X</em> OP_0NOTEQUAL</samp></td>
</tr>
<tr>
  <td><code>l:<em>X</em></code> = <code>or_i(0,<em>X</em>)</code></td>
  <td><samp>OP_IF OP_0 OP_ELSE <em>X</em> OP_ENDIF</samp></td>
</tr>
<tr>
  <td><code>u:<em>X</em></code> = <code>or_i(<em>X</em>,0)</code></td>
  <td><samp>OP_IF <em>X</em> OP_ELSE 0 OP_ENDIF</samp></td>
</tr>
</tbody>
</table>

<h4>Correctness properties</h4>

<p>
Not every Miniscript expression can be composed with every other. Some return their result by putting zero or false on the stack; others distinguish by aborting or continuing.
Some require subexpressions that consume an exactly known number of arguments, while others need a subexpression that has a nonzero top stack element to satisfy. To model all
these properties, we define a correctness type system for Miniscript.
</p>

<p>
Every miniscript expression has one of four basic types:<ul>
<li><b>"B"</b> Base expressions:<ul>
  <li>Takes its inputs from the top of the stack.</li>
  <li>When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.</li>
  <li>When dissatisfied, pushes a 0 onto the stack.</li>
  <li>This is used for most expressions, and required for the top level one.</li>
  <li>For example: <code>older(n)</code> = <samp>&lt;n&gt; OP_CHECKSEQUENCEVERIFY</samp>.</li>
</ul></li>
<li><b>"V"</b> Verify expressions:<ul>
  <li>Takes its inputs from the top of the stack.</li>
  <li>When satisfactied, pushes nothing.</li>
  <li>Cannot be dissatisfied (aborts execution instead).</li>
  <li>A "V" can be obtained using the v: wrapper on a "B" expression, or by combining other "V" expressions using and_v, or_i, or andor.</li>
  <li>For example <code>vc:pk(key)</code> = <samp>&lt;key&gt; OP_CHECKSIGVERIFY</samp>.</li>
</ul></li>
<li><b>"K"</b> Key expressions:<ul>
  <li>Takes its inputs from the top of the stack.</li>
  <li>Always pushes a public key onto the stack, for which a signature is to be provided to satisfy the expression.</li>
  <li>Can be converted into a "B" using the c: wrapper (OP_CHECKSIG).</li>
  <li>For example <code>pk_h(key)</code> = <samp>OP_DUP OP_HASH160 &lt;Hash160(key)&gt; OP_EQUALVERIFY</samp></li>
</ul></li>
<li><b>"W"</b> Wrapped expressions:<ul>
  <li>Takes its input from one below the top of the stack.</li>
  <li>When satisfied, pushes a nonzero value (like B) on top of the stack, or one below the top.</li>
  <li>When dissatisfied, pushes 0 op top of the stack or one below the top.</li>
  <li>Every "W" is either s:B (OP_SWAP B) or a:B (OP_TOALTSTACK B OP_FROMALTSTACK).</li>
  <li>For example <code>sc:pk(key)</code> = <samp>OP_SWAP &lt;key&gt; OP_CHECKSIG</samp>.</li>
</ul></li>
</ul>
</p>

<p>
Then there are 5 type modifiers, which guarantee additional properties:<ul>
<li><b>"z"</b> Zero-arg: this expression always consumes exactly 0 stack elements.</li>
<li><b>"o"</b> One-arg: this expression always consumes exactly 1 stack element.</li>
<li><b>"n"</b> Nonzero: no satisfaction for this expression requires a top stack element that is zero.</li>
<li><b>"d"</b> Dissatisfiable: this expression can be dissatisfied by anyone.</li>
<li><b>"u"</b> Unit: when satisfied, this expression will put an exact 1 on the stack (as opposed to any nonzero value).</li>
</ul>
</p>

<p>
This tables lists the correctness requirements for each of the Miniscript expressions, and its type properties in function of those of their subexpressions:
<table class="table table-sm">
<thead class="thead-light"><tr><th scope="col">Miniscript</th><th scope="col">Requires</th><th scope="col">Type</th><th scope="col">Properties</th></tr></thead>
<tbody>
<tr><td>0        </td><td></td><td>B</td><td>z; u; d</td></tr>
<tr><td>1        </td><td></td><td>B</td><td>z; u</td></tr>
<tr><td>pk(key)  </td><td></td><td>K</td><td>o; n; d; u</td></tr>
<tr><td>pk_h(key)</td><td></td><td>K</td><td>n; d; u</td></tr>
<tr><td>older(n), after(n) </td><td>1 &le; n &lt; 2<sup>31</sup></td><td>B</td><td>z</td></tr>
<tr><td>sha256(h)</td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td>ripemd160(h)</td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td>hash256(h)</td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td>hash160(h)</td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td>and_v(X,Y)</td><td>X is V; Y is B, K, or V</td><td>same as Y</td><td>z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; u=u<sub>Y</sub></td></tr>
<tr><td>and_b(X,Y)</td><td>X is B; Y is W</td><td>B</td><td>z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; d=d<sub>X</sub>d<sub>Y</sub>; u</td></tr>
<tr><td>or_b(X,Z)</td><td>X is Bd; Z is Wd</td><td>B</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; d; u</td></tr>
<tr><td>or_c(X,Z)</td><td>X is Bdu; Z is V</td><td>V</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub></td></tr>
<tr><td>or_d(X,Z)</td><td>X is Bdu; Z is B</td><td>B</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub>; d=d<sub>Z</sub>; u=u<sub>Z</sub></td></tr>
<tr><td>or_i(X,Z)</td><td>both are B, K, or V</td><td>same as X/Z</td><td>o=z<sub>X</sub>z<sub>Z</sub>; u=u<sub>X</sub>u<sub>Z</sub>; d=d<sub>X</sub> or d<sub>Z</sub></td></tr>
<tr><td>andor(X,Y,Z)</td><td>X is Bdu; Y and Z are both B, K, or V</td><td>same as Y/Z</td><td>z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub> or o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; u=u<sub>Y</sub>u<sub>Z</sub>; d=d<sub>Z</sub></td></tr>
<tr><td>thresh(k,X,Y,Z,...)</td><td>1 &lt; k &lt; n; first is Bdu; others are Wdu</td><td>B</td><td>z=all are z; o=all are z except one is o; d; u</td></tr>
<tr><td>thresh_m(k,key<sub>1</sub>,...,key<sub>n</sub>)</td><td>1 &le; k &le; n</td><td>B</td><td>n; d; u</td></tr>
<tr><td>a:X</td><td>X is B</td><td>W</td><td>d=d<sub>X</sub>; u=u<sub>X</sub></td></tr>
<tr><td>s:X</td><td>X is Bo</td><td>W</td><td>d=d<sub>X</sub>; u=u<sub>X</sub></td></tr>
<tr><td>c:X</td><td>X is K</td><td>B</td><td>o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u</td></tr>
<tr><td>d:X</td><td>X is Vz</td><td>B</td><td>o=z<sub>X</sub>; n; u; d</td></tr>
<tr><td>v:X</td><td>X is B</td><td>V</td><td>z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub></td></tr>
<tr><td>j:X</td><td>X is Bn</td><td>B</td><td>o=o<sub>X</sub>; n; d; u=u<sub>X</sub></td></tr>
<tr><td>n:X</td><td>X is B</td><td>B</td><td>z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u</td></tr>
</tbody>
</table>
</p>

</div>
</div>

<div class="card mb-3 text-left">
<h3 class="card-header">Compiler demo</h3>
<div class="card-block">

<textarea rows="1" cols="100" id="source">
and(pk(C),or(pk(C),or(9@pk(C),older(1000))))
</textarea><br/>
<button type="button" onclick="miniscript_compile();">Compile</button>
Supported elements:
<ul>
<li><b>pk(HEX)</b>: Require public key HEX to sign.</li>
<li><b>time(NUMBER)</b>: Require that a relative time NUMBER has passed since creating the output.</li>
<li><b>hash(HEX)</b>: Require that the SHA256 preimage of HEX is revealed.</li>
<li><b>and(EXPR,EXPR)</b>: Require that both subexpressions are satisfied.</li>
<li><b>or([N@]EXPR,[N@]EXPR)</b>: Require that one of the subexpressions is satisfied. The numbers N indicate the relative probability of each of the subexpressions.</li>
<li><b>thresh(NUM,EXPR,EXPR,...)</b>: Require that NUM out of the following subexpressions are satisfied.</li>
</ul>
Shorthands:
<ul>
<li><b>C</b>: A dummy compressed public key (usable as argument to pk or multi)</li>
<li><b>U</b>: A dummy uncompressed public key (usable as argument to pk or multi)</li>
<li><b>H</b>: A dummy hash (usable as argument to hash)</li>
</ul>

<hr/>
<b>Miniscript output</b><br/>
<textarea rows="4" cols="100" id="descout"></textarea>
<button type="button" onclick="miniscript_analyze();">Analyze</button>

<hr/>
<b>Analysis</b><br/>
<a id="spendout"></a>
</div>
</div>


<div class="card text-left">
<h3 class="card-header">Miniscript reference</h3>
<div class="card-block">

<table border="1">
<tr><th>Type</th><th>Shorthand</th><th>Behavior under honest inputs</th><th>Behavior under adverserial inputs</th></tr>
<tr><td>Base</td><td>B</td><td>Takes its inputs from the top of the stack. Pushes a nonzero value of up to 4 bytes if the condition is satisfied, exactly zero otherwise.</td><td>Pushes zero onto the stack, or aborts.</td></tr>
<tr><td>Key</td><td>K</td><td>Takes its inputs from the top of the stack. Pushes a public key with which a checksig is to be done onto the stack.</td><td>Aborts.</td></tr>
<tr><td>Verify</td><td>V</td><td>Takes its inputs from the top of the stack, which must satisfy the condition. Does not push anything onto the stack.</td><td>Aborts.</td></tr>
<tr><td>Wrapped</td><td>W</td><td>Takes from the stack its inputs + element X at the top. If the inputs satisfy the condition, [t X] or [X t] is pushed, where t is a nonzero value of up to 4 bytes. If not, [0 X] or [X 0] is pushed.</td><td>Pushes [0 X] or [X 0] onto the stack, or aborts.</td></tr>
</table>

In addition, every expression can have zero or more of the following properties used for reasoning about correctness:<ul>
<li><b>z</b> "zero": Known to consume exactly zero stack elements. Conflicts with "o".</li>
<li><b>o</b> "one": Known to consume exactly one stack element. Conflicts with "z".</li>
<li><b>n</b> "nonzero": Known to consume at least one stack element, and the top element is never required to be 0 to satisfy the condition. Conflicts with "z". Impossible for W.</li>
<li><b>d</b> "dissatisfiable": There is a guaranteed way to this dissatisfy the expression. Impossible for V.</li>
<li><b>u</b> "unit": Satisfaction always results in an exact 1 on the stack (as opposed to arbitrary nonzero value). Impossible for V. Implied by K</li>
</ul>

There are also four more properties that let us reason about nonmalleability:<ul>
<li><b>e</b> "expr": A unique way to dissatisfy this expression exists which cannot be modified into another dissatisfaction by an attacker. Conflicts with "f". Implies "d". Impossible for V.</li>
<li><b>f</b> "forced": There is no way to dissatisfy the expression, either under honest or malicious input. Conflicts with "d" and "e". Implied by V.</li>
<li><b>s</b> "safe": Satisfying this expression requires at least one signature. This means a dissatisfaction cannot be converted into a satisfaction for this expression. Implied by K.</li>
<li><b>m</b> "nonmalleable": For every way the condition can be met, a unique satisfaction exists which cannot be modified into another satisfaction by an attacker. Implied by Z.</li>
</ul>

<h3>Legend</h3>

<table border="1">
<tr>
  <th>Semantics</th>
  <th>Node</th>
  <th>Script</th>
  <th>nsat</th>
  <th>sat (X,Y)</th>
  <th>sat Z</th>
  <th>Types</th>
  <th>Req.</th>
  <th>Corr. prop.</th>
  <th>Mall. prop.</th>
</tr>
<tr>
  <td rowspan="2">check(key)</td>
  <td>pk(key)</td>
  <td>key</td>
  <td>0</td>
  <td>sig</td>
  <td>-</td>
  <td>K</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td>pk_h(keyhash)</td>
  <td>DUP HASH160 keyhash EQUALVERFIFY</td>
  <td>0 key</td>
  <td>sig key</td>
  <td>-</td>
  <td>K</td>
  <td></td>
  <td>n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td>nSequence &ge; n (and compatible)</td>
  <td>older(n)</td>
  <td>n CHECKSEQUENCEVERIFY</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td>n &ge; 1</td>
  <td>z</td>
  <td>f, m</td>
</tr>
<tr>
  <td>nLockTime &ge; n (and compaitlbe)</td>
  <td>after(n)</td>
  <td>n CHECKLOCKTIMEVERIFY</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td>2<sup>31</sup> > n &ge; 1</td>
  <td>z</td>
  <td>f, m</td>
</tr>
<tr>
  <td>len(x) = 32 and SHA256(x) = h</td>
  <td>sha256(h)</td>
  <td>SIZE 32 EQUALVERIFY SHA256 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and HASH256(x) = h</td>
  <td>hash256(h)</td>
  <td>SIZE 32 EQUALVERIFY HASH256 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and RIPEMD160(x) = h</td>
  <td>ripemd160(h)</td>
  <td>SIZE 32 EQUALVERIFY RIPEMD160 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and HASH160(x) = h</td>
  <td>hash160(h)</td>
  <td>SIZE 32 EQUALVERIFY HASH160 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td rowspan="3">X and Y</td>
  <td>and_v(X,Y)</td>
  <td>[X] [Y]</td>
  <td>-</td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=V<sub>X</sub>B<sub>Y</sub><br />K=V<sub>X</sub>K<sub>Y</sub><br />V=V<sub>X</sub>V<sub>Y</sub></td>
  <td></td>
  <td>
      u=u<sub>Y</sub><br />
      n=n<sub>X</sub>+z<sub>X</sub>n<sub>Y</sub><br />
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>+o<sub>X</sub>z<sub>Y</sub>
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Y</sub>[=f<sub>Y</sub>]<br />
      m=m<sub>X</sub>m<sub>Y</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td>and_b(X,Y)</td>
  <td>[X] [Y] BOOLAND</td>
  <td>nsat<sub>Y</sub> nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub>W<sub>Y</sub></td>
  <td></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>+o<sub>X</sub>z<sub>Y</sub><br />
      n=n<sub>X</sub>+z<sub>X</sub>n<sub>Y</sub><br />
      d=d<sub>X</sub>d<sub>Y</sub><br />
      u
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Y</sub><br />
      e=e<sub>X</sub>e<sub>Y</sub>s<sub>X</sub>s<sub>Y</sub><br />
      m=m<sub>X</sub>m<sub>Y</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td>and_n(X,Y)</td>
  <td>[X] NOTIF 0 ELSE [Y] ENDIF (=andor(X,Y,0))</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub>B<sub>Y</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=o<sub>X</sub>z<sub>Y</sub><br />
      u=u<sub>Y</sub><br />
      d=d<sub>X</sub>[=1]
  </td>
  <td>
      f=f<sub>Y</sub>f<sub>X</sub>[=0]<br />
      e=e<sub>X</sub>(s<sub>X</sub>+f<sub>Y</sub>)<br />
      m=m<sub>X</sub>m<sub>Y</sub>e<sub>X</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td rowspan="4">X or Z</td>
  <td>or_b(X,Z)</td>
  <td>[X] [Z] BOOLOR</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>nsat<sub>Z</sub> sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>W<sub>Z</sub></td>
  <td>d<sub>X</sub>d<sub>Z</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=z<sub>X</sub>o<sub>Z</sub>+o<sub>X</sub>z<sub>Z</sub><br />
      d=d<sub>X</sub>d<sub>Z</sub>[=1]<br />
      u
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=0]<br />
      e=e<sub>X</sub>e<sub>Z</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>e<sub>Z</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_d(X,Z)</td>
  <td>[X] IFDUP NOTIF [Z] ENDIF</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>B<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=o<sub>X</sub>z<sub>Z</sub><br />
      u=u<sub>X</sub>(f<sub>X</sub>+u<sub>Z</sub>)[=u<sub>Z</sub>]<br />
      d=d<sub>X</sub>d<sub>Z</sub>[=d<sub>Z</sub>]
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=f<sub>Z</sub>]<br />
      e=e<sub>X</sub>e<sub>Z</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_c(X,Z)</td>
  <td>[X] NOTIF [Z] ENDIF</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>V=B<sub>X</sub>V<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=o<sub>X</sub>z<sub>Z</sub>
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=1]<br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_i(X,Z)</td>
  <td>IF [X] ELSE [Z] ENDIF</td>
  <td>nsat<sub>X</sub> 1<br />nsat<sub>Z</sub> 0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>sat<sub>Z</sub> 0</td>
  <td>V=V<sub>X</sub>V<sub>Z</sub><br />B=B<sub>X</sub>B<sub>Z</sub><br />K=K<sub>X</sub>K<sub>Z</sub></td>
  <td></td>
  <td>
      o=z<sub>X</sub>z<sub>Z</sub><br />
      u=u<sub>X</sub>u<sub>Z</sub><br />
      d=d<sub>X</sub>+d<sub>Z</sub>
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Z</sub><br />
      e=e<sub>X</sub>f<sub>Z</sub>+e<sub>Z</sub>f<sub>X</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>(X and Y) or Z</td>
  <td>andor(X,Y,Z)</td>
  <td>[X] NOTIF [Z] ELSE [Y] ENDIF</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>B<sub>Y</sub>B<sub>Z</sub><br />K=B<sub>X</sub>K<sub>Y</sub>K<sub>Z</sub><br />V=B<sub>X</sub>V<sub>Y</sub>V<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub>+o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub><br />
      u=u<sub>Y</sub>u<sub>Z</sub><br />
      d=d<sub>X</sub>d<sub>Z</sub>[=d<sub>Z</sub>]
  </td>
  <td>
      f=f<sub>Y</sub>(f<sub>X</sub>+f<sub>Z</sub>)[=f<sub>Y</sub>f<sub>Z</sub>]<br />
      e=e<sub>X</sub>e<sub>Z</sub>(s<sub>X</sub>+f<sub>Y</sub>)<br />
      m=m<sub>X</sub>m<sub>Y</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Y</sub>+s<sub>Z</sub>)<br />
      s=s<sub>Z</sub>(s<sub>X</sub>+s<sub>Y</sub>)
  </td>
</tr>
<tr>
  <td>X<sub>1</sub> + ... + X<sub>n</sub> = k</td>
  <td>thresh(k,...)</td>
  <td>[X<sub>1</sub>] ([X<sub>i</sub> ADD)*(n-1) k EQUAL</td>
  <td>nsat...</td>
  <td>(sat|nsat)...</td>
  <td>-</td>
  <td>B=X<sub>1</sub> is B<br />others are W</td>
  <td>n > k > 1<br />all are d and u</td>
  <td>
      z=all are z<br />
      o=all are z, except one is o<br />
      d<br />
      u
  </td>
  <td>
      e=all are e and s<br />
      m=all are e and m, &ge;(n-k) are s<br />
      s=&ge;(n-k+1) are s
  </td>
</tr>
<tr>
  <td>check(key_1) + ... = k</td>
  <td>thresh_m(k,...)</td>
  <td>k key_1 ... key_n n CHECKMULTISIG</td>
  <td>0 0 ... 0</td>
  <td>0 sig...</td>
  <td>-</td>
  <td>B</td>
  <td>n &ge; k &ge; 1</td>
  <td>n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td rowspan="10">X</td>
  <td>a:X</td>
  <td>TOALTSTACK [X] FROMALTSTACK</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>W=B<sub>X</sub></td>
  <td></td>
  <td>u=u<sub>X</sub>, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>s:X</td>
  <td>SWAP [X]</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>o<sub>X</sub></td>
  <td>W=B<sub>X</sub></td>
  <td></td>
  <td>u=u<sub>x</sub>, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>c:X</td>
  <td>[X] CHECKSIG</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=K<sub>X</sub></td>
  <td></td>
  <td>o=o<sub>X</sub>, n=n<sub>X</sub>, u, d=d<sub>X</sub></td>
  <td>e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub>[=1]</td>
</tr>
<tr>
  <td>t:X</td>
  <td>[X] 1 (=and_v(X,1))</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=V<sub>X</sub></td>
  <td></td>
  <td>u, n=n<sub>X</sub>, z=z<sub>X</sub>, o=o<sub>X</sub></td>
  <td>f, m=m<sub>X</sub>, s=s<sub>X</sub></td>
<tr>
  <td>d:X</td>
  <td>DUP IF [X] ENDIF</td>
  <td>0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>-</td>
  <td>B=V<sub>X</sub></td>
  <td>z<sub>X</sub></td>
  <td>o=z<sub>X</sub>, n, u, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>v:X</td>
  <td>[X] VERIFY</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>V=B<sub>X</sub></td>
  <td></td>
  <td>z=z<sub>X</sub>, o=o<sub>X</sub>, n=n<sub>X</sub></td>
  <td>f, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>j:X</td>
  <td>SIZE 0NOTEQUAL IF [X] ENDIF</td>
  <td>0</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td>n<sub>X</sub></td>
  <td>o=o<sub>X</sub>, n, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>n:X</td>
  <td>[X] 0NOTEQUAL</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>z=z<sub>X</sub>, o=o<sub>X</sub>, n=n<sub>X</sub>, u, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>l:X</td>
  <td>IF 0 ELSE [X] ENDIF (=or_i(0,X))</td>
  <td>1</td>
  <td>sat<sub>X</sub> 0</td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>o=z<sub>X</sub>, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>u:X</td>
  <td>IF [X] ELSE 0 ENDIF (=or_i(X,0))</td>
  <td>0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>o=z<sub>X</sub>, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>true</td>
  <td>1</td>
  <td>1</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>z, u</td>
  <td>f, m</td>
</tr>
<tr>
  <td>false</td>
  <td>0</td>
  <td>0</td>
  <td>[]</td>
  <td>-</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>z, u, d</td>
  <td>e, m, s</td>
</tr>
</table>

</div>
</div>
</div>

</body>
</html>
